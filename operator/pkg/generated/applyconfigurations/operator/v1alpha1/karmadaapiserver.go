/*
Copyright The Karmada Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "k8s.io/api/core/v1"
	corev1 "k8s.io/client-go/applyconfigurations/core/v1"
)

// KarmadaAPIServerApplyConfiguration represents a declarative configuration of the KarmadaAPIServer type for use
// with apply.
//
// KarmadaAPIServer holds settings to kube-apiserver component of the kubernetes.
// Karmada uses it as its own apiserver in order to provide Kubernetes-native APIs.
type KarmadaAPIServerApplyConfiguration struct {
	// CommonSettings holds common settings to kubernetes api server.
	CommonSettingsApplyConfiguration `json:",inline"`
	// ServiceSubnet is the subnet used by k8s services. Defaults to "10.96.0.0/12".
	ServiceSubnet *string `json:"serviceSubnet,omitempty"`
	// ServiceType represents the service type of Karmada API server.
	// Valid options are: "ClusterIP", "NodePort", "LoadBalancer".
	// Defaults to "ClusterIP".
	ServiceType *v1.ServiceType `json:"serviceType,omitempty"`
	// LoadBalancerClass specifies the load balancer implementation class for the Karmada API server.
	// This field is applicable only when ServiceType is set to LoadBalancer.
	// If specified, the service will be processed by the load balancer implementation that matches the specified class.
	// By default, this is not set and the LoadBalancer type of Service uses the cloud provider's default load balancer
	// implementation.
	// Once set, it cannot be changed. The value must be a label-style identifier, with an optional prefix such as
	// "internal-vip" or "example.com/internal-vip".
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-class
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty"`
	// ServiceAnnotations is an extra set of annotations for service of karmada apiserver.
	// more info: https://github.com/karmada-io/karmada/issues/4634
	ServiceAnnotations map[string]string `json:"serviceAnnotations,omitempty"`
	// ExtraArgs is an extra set of flags to pass to the kube-apiserver component or
	// override. A key in this map is the flag name as it appears on the command line except
	// without leading dash(es).
	//
	// Note: This is a temporary solution to allow for the configuration of the
	// kube-apiserver component. In the future, we will provide a more structured way
	// to configure the component. Once that is done, this field will be discouraged to be used.
	// Incorrect settings on this field maybe lead to the corresponding component in an unhealthy
	// state. Before you do it, please confirm that you understand the risks of this configuration.
	//
	// For supported flags, please see
	// https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
	// for details.
	ExtraArgs map[string]string `json:"extraArgs,omitempty"`
	// ExtraVolumes specifies a list of extra volumes for the API server's pod
	// To fulfil the base functionality required for a functioning control plane, when provisioning a new Karmada instance,
	// the operator will automatically attach volumes for the API server pod needed to configure things such as TLS,
	// SA token issuance/signing and secured connection to etcd, amongst others. However, given the wealth of options for configurability,
	// there are additional features (e.g., encryption at rest and custom AuthN webhook) that can be configured. ExtraVolumes, in conjunction
	// with ExtraArgs and ExtraVolumeMounts can be used to fulfil those use cases.
	ExtraVolumes []corev1.VolumeApplyConfiguration `json:"extraVolumes,omitempty"`
	// ExtraVolumeMounts specifies a list of extra volume mounts to be mounted into the API server's container
	// To fulfil the base functionality required for a functioning control plane, when provisioning a new Karmada instance,
	// the operator will automatically mount volumes into the API server container needed to configure things such as TLS,
	// SA token issuance/signing and secured connection to etcd, amongst others. However, given the wealth of options for configurability,
	// there are additional features (e.g., encryption at rest and custom AuthN webhook) that can be configured. ExtraVolumeMounts, in conjunction
	// with ExtraArgs and ExtraVolumes can be used to fulfil those use cases.
	ExtraVolumeMounts []corev1.VolumeMountApplyConfiguration `json:"extraVolumeMounts,omitempty"`
	// CertSANs sets extra Subject Alternative Names for the API Server signing cert.
	CertSANs []string `json:"certSANs,omitempty"`
	// FeatureGates enabled by the user.
	// More info: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
	FeatureGates map[string]bool `json:"featureGates,omitempty"`
	// SidecarContainers specifies a list of sidecar containers to be deployed
	// within the Karmada API server pod.
	// This enables users to integrate auxiliary services such as KMS plugins for configuring encryption at rest.
	SidecarContainers []corev1.ContainerApplyConfiguration `json:"sidecarContainers,omitempty"`
}

// KarmadaAPIServerApplyConfiguration constructs a declarative configuration of the KarmadaAPIServer type for use with
// apply.
func KarmadaAPIServer() *KarmadaAPIServerApplyConfiguration {
	return &KarmadaAPIServerApplyConfiguration{}
}

// WithImageRepository sets the ImageRepository field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ImageRepository field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithImageRepository(value string) *KarmadaAPIServerApplyConfiguration {
	b.ImageApplyConfiguration.ImageRepository = &value
	return b
}

// WithImageTag sets the ImageTag field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ImageTag field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithImageTag(value string) *KarmadaAPIServerApplyConfiguration {
	b.ImageApplyConfiguration.ImageTag = &value
	return b
}

// WithImagePullPolicy sets the ImagePullPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ImagePullPolicy field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithImagePullPolicy(value v1.PullPolicy) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.ImagePullPolicy = &value
	return b
}

// WithReplicas sets the Replicas field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Replicas field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithReplicas(value int32) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.Replicas = &value
	return b
}

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *KarmadaAPIServerApplyConfiguration) WithLabels(entries map[string]string) *KarmadaAPIServerApplyConfiguration {
	if b.CommonSettingsApplyConfiguration.Labels == nil && len(entries) > 0 {
		b.CommonSettingsApplyConfiguration.Labels = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.CommonSettingsApplyConfiguration.Labels[k] = v
	}
	return b
}

// WithAnnotations puts the entries into the Annotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Annotations field,
// overwriting an existing map entries in Annotations field with the same key.
func (b *KarmadaAPIServerApplyConfiguration) WithAnnotations(entries map[string]string) *KarmadaAPIServerApplyConfiguration {
	if b.CommonSettingsApplyConfiguration.Annotations == nil && len(entries) > 0 {
		b.CommonSettingsApplyConfiguration.Annotations = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.CommonSettingsApplyConfiguration.Annotations[k] = v
	}
	return b
}

// WithResources sets the Resources field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Resources field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithResources(value *corev1.ResourceRequirementsApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.Resources = value
	return b
}

// WithPriorityClassName sets the PriorityClassName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PriorityClassName field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithPriorityClassName(value string) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.PriorityClassName = &value
	return b
}

// WithPodDisruptionBudgetConfig sets the PodDisruptionBudgetConfig field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PodDisruptionBudgetConfig field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithPodDisruptionBudgetConfig(value *PodDisruptionBudgetConfigApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.PodDisruptionBudgetConfig = value
	return b
}

// WithTolerations adds the given value to the Tolerations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Tolerations field.
func (b *KarmadaAPIServerApplyConfiguration) WithTolerations(values ...*corev1.TolerationApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithTolerations")
		}
		b.CommonSettingsApplyConfiguration.Tolerations = append(b.CommonSettingsApplyConfiguration.Tolerations, *values[i])
	}
	return b
}

// WithAffinity sets the Affinity field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Affinity field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithAffinity(value *corev1.AffinityApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	b.CommonSettingsApplyConfiguration.Affinity = value
	return b
}

// WithServiceSubnet sets the ServiceSubnet field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ServiceSubnet field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithServiceSubnet(value string) *KarmadaAPIServerApplyConfiguration {
	b.ServiceSubnet = &value
	return b
}

// WithServiceType sets the ServiceType field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ServiceType field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithServiceType(value v1.ServiceType) *KarmadaAPIServerApplyConfiguration {
	b.ServiceType = &value
	return b
}

// WithLoadBalancerClass sets the LoadBalancerClass field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LoadBalancerClass field is set to the value of the last call.
func (b *KarmadaAPIServerApplyConfiguration) WithLoadBalancerClass(value string) *KarmadaAPIServerApplyConfiguration {
	b.LoadBalancerClass = &value
	return b
}

// WithServiceAnnotations puts the entries into the ServiceAnnotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the ServiceAnnotations field,
// overwriting an existing map entries in ServiceAnnotations field with the same key.
func (b *KarmadaAPIServerApplyConfiguration) WithServiceAnnotations(entries map[string]string) *KarmadaAPIServerApplyConfiguration {
	if b.ServiceAnnotations == nil && len(entries) > 0 {
		b.ServiceAnnotations = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.ServiceAnnotations[k] = v
	}
	return b
}

// WithExtraArgs puts the entries into the ExtraArgs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the ExtraArgs field,
// overwriting an existing map entries in ExtraArgs field with the same key.
func (b *KarmadaAPIServerApplyConfiguration) WithExtraArgs(entries map[string]string) *KarmadaAPIServerApplyConfiguration {
	if b.ExtraArgs == nil && len(entries) > 0 {
		b.ExtraArgs = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.ExtraArgs[k] = v
	}
	return b
}

// WithExtraVolumes adds the given value to the ExtraVolumes field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ExtraVolumes field.
func (b *KarmadaAPIServerApplyConfiguration) WithExtraVolumes(values ...*corev1.VolumeApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithExtraVolumes")
		}
		b.ExtraVolumes = append(b.ExtraVolumes, *values[i])
	}
	return b
}

// WithExtraVolumeMounts adds the given value to the ExtraVolumeMounts field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ExtraVolumeMounts field.
func (b *KarmadaAPIServerApplyConfiguration) WithExtraVolumeMounts(values ...*corev1.VolumeMountApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithExtraVolumeMounts")
		}
		b.ExtraVolumeMounts = append(b.ExtraVolumeMounts, *values[i])
	}
	return b
}

// WithCertSANs adds the given value to the CertSANs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the CertSANs field.
func (b *KarmadaAPIServerApplyConfiguration) WithCertSANs(values ...string) *KarmadaAPIServerApplyConfiguration {
	for i := range values {
		b.CertSANs = append(b.CertSANs, values[i])
	}
	return b
}

// WithFeatureGates puts the entries into the FeatureGates field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the FeatureGates field,
// overwriting an existing map entries in FeatureGates field with the same key.
func (b *KarmadaAPIServerApplyConfiguration) WithFeatureGates(entries map[string]bool) *KarmadaAPIServerApplyConfiguration {
	if b.FeatureGates == nil && len(entries) > 0 {
		b.FeatureGates = make(map[string]bool, len(entries))
	}
	for k, v := range entries {
		b.FeatureGates[k] = v
	}
	return b
}

// WithSidecarContainers adds the given value to the SidecarContainers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SidecarContainers field.
func (b *KarmadaAPIServerApplyConfiguration) WithSidecarContainers(values ...*corev1.ContainerApplyConfiguration) *KarmadaAPIServerApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithSidecarContainers")
		}
		b.SidecarContainers = append(b.SidecarContainers, *values[i])
	}
	return b
}

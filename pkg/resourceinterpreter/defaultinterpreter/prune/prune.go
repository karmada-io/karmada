package prune

import (
	"fmt"
	"strings"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/karmada-io/karmada/pkg/util"
	"github.com/karmada-io/karmada/pkg/util/helper"
)

// RemoveIrrelevantField used to remove fields that generated by kube-apiserver and no need(or can't) propagate to
// member clusters.
func RemoveIrrelevantField(workload *unstructured.Unstructured) error {
	fields := getIrrelevantFields()
	for _, field := range fields {
		unstructured.RemoveNestedField(workload.Object, field...)
	}

	if workload.GetKind() == util.ServiceKind {
		// In the case spec.clusterIP is set to `None`, means user want a headless service,  then it shouldn't be removed.
		clusterIP, exist, _ := unstructured.NestedString(workload.Object, "spec", "clusterIP")
		if exist && clusterIP != corev1.ClusterIPNone {
			unstructured.RemoveNestedField(workload.Object, "spec", "clusterIP")
			unstructured.RemoveNestedField(workload.Object, "spec", "clusterIPs")
		}
	}

	if workload.GetKind() == util.JobKind {
		job, err := helper.ConvertToJob(workload)
		if err != nil {
			return err
		}

		if job.Spec.ManualSelector == nil || !*job.Spec.ManualSelector {
			return removeGenerateSelectorOfJob(workload)
		}
	}

	if workload.GetKind() == util.ServiceAccountKind {
		secrets, exist, _ := unstructured.NestedSlice(workload.Object, "secrets")
		// If 'secrets' exists in ServiceAccount, remove the automatic generation secrets(e.g. default-token-xxx)
		if exist && len(secrets) > 0 {
			tokenPrefix := fmt.Sprintf("%s-token-", workload.GetName())
			for idx := 0; idx < len(secrets); idx++ {
				if strings.HasPrefix(secrets[idx].(map[string]interface{})["name"].(string), tokenPrefix) {
					secrets = append(secrets[:idx], secrets[idx+1:]...)
				}
			}
			_ = unstructured.SetNestedSlice(workload.Object, secrets, "secrets")
		}
	}

	return nil
}

func removeGenerateSelectorOfJob(workload *unstructured.Unstructured) error {
	matchLabels, exist, err := unstructured.NestedStringMap(workload.Object, "spec", "selector", "matchLabels")
	if err != nil {
		return err
	}
	if exist {
		if util.GetLabelValue(matchLabels, "controller-uid") != "" {
			delete(matchLabels, "controller-uid")
		}
		err = unstructured.SetNestedStringMap(workload.Object, matchLabels, "spec", "selector", "matchLabels")
		if err != nil {
			return err
		}
	}

	templateLabels, exist, err := unstructured.NestedStringMap(workload.Object, "spec", "template", "metadata", "labels")
	if err != nil {
		return err
	}
	if exist {
		if util.GetLabelValue(templateLabels, "controller-uid") != "" {
			delete(templateLabels, "controller-uid")
		}

		if util.GetLabelValue(templateLabels, "job-name") != "" {
			delete(templateLabels, "job-name")
		}

		err = unstructured.SetNestedStringMap(workload.Object, templateLabels, "spec", "template", "metadata", "labels")
		if err != nil {
			return err
		}
	}
	return nil
}

// irrelevantFields populated by the kubernetes and should not be propagated to member clusters.
// deletionGracePeriodSeconds:  kubernetes will set this fields in case of graceful deletion
// managedFields: this is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field.Remove this field to keep 'Work' clean and tidy.
func getIrrelevantFields() [][]string {
	return [][]string{
		{"metadata", "creationTimestamp"},
		{"metadata", "deletionTimestamp"},
		{"metadata", "deletionGracePeriodSeconds"},
		{"metadata", "generation"},
		{"metadata", "managedFields"},
		{"metadata", "resourceVersion"},
		{"metadata", "selfLink"},
		{"metadata", "uid"},
		{"metadata", "ownerReferences"},
		{"status"},
	}
}

apiVersion: config.karmada.io/v1alpha1
kind: ResourceInterpreterCustomization
metadata:
  name: declarative-configuration-tfjob
spec:
  target:
    apiVersion: kubeflow.org/v1
    kind: TFJob
  customizations:
    componentResource:
      luaScript: |
        local kube = require("kube")
        
        -- Safe fetch of deeply nested table fields.
        local function get(obj, path)
          local cur = obj
          for i = 1, #path do
            if cur == nil then
              return nil
            end
            cur = cur[path[i]]
          end
          return cur
        end
        
        -- Normalize possibly-string numbers with a default.
        local function to_num(v, default)
          if v == nil or v == '' then
            return default
          end
          local n = tonumber(v)
          if n ~= nil then
            return n
          end
          return default
        end
        
        function GetComponents(observedObj)
          local components = {}
          
          -- Define all supported TFJob replica types
          local replicaTypes = {
            {key = "PS", name = "ps"},
            {key = "Worker", name = "worker"},
            {key = "Chief", name = "chief"},
            {key = "Master", name = "master"},
            {key = "Evaluator", name = "evaluator"}
          }
          
          -- Iterate through all replica types
          for _, replicaType in ipairs(replicaTypes) do
            local spec = get(observedObj, {"spec", "tfReplicaSpecs", replicaType.key})
            if spec ~= nil then
              local replicas = to_num(spec.replicas, 1)
              local template = spec.template
              
              local requires = {}
              if template ~= nil then
                requires = kube.accuratePodRequirements(template)
              end
              
              local component = {
                name = replicaType.name,
                replicas = replicas,
                replicaRequirements = requires
              }
              table.insert(components, component)
            end
          end
          
          return components
        end

    statusAggregation:
      luaScript: >
        local function omitEmpty(t)
          if t == nil then return nil end
          local out = {}
          for k, v in pairs(t) do
            if type(v) == "table" then
              local inner = omitEmpty(v)
              if inner ~= nil and next(inner) ~= nil then
                out[k] = inner
              end
            elseif v ~= nil and not (v == 0 or v == "" or v == "0s") then
              out[k] = v
            end
          end
          if next(out) ~= nil then
            return out
          else
            return nil
          end
        end
        function AggregateStatus(desiredObj, statusItems)
          if desiredObj.status == nil then
            desiredObj.status = {}
          end
        
          -- If no member cluster status, initialize default status
          if statusItems == nil then
            desiredObj.status.startTime = nil
            desiredObj.status.completionTime = nil
            desiredObj.status.replicaStatuses = {}
            desiredObj.status.conditions = {}
            return desiredObj
          end
        
          local startTime = nil
          local completionTime = nil
          local lastReconcileTime = nil
          local replicaStatuses = {}
          local aggregatedConditions = {}
          local successfulClustersNum = 0
          local failedClusters = {}
        
          -- Initialize all TFJob replica types status
          replicaStatuses.PS = { active = 0, failed = 0, succeeded = 0 }
          replicaStatuses.Worker = { active = 0, failed = 0, succeeded = 0 }
          replicaStatuses.Chief = { active = 0, failed = 0, succeeded = 0 }
          replicaStatuses.Master = { active = 0, failed = 0, succeeded = 0 }
          replicaStatuses.Evaluator = { active = 0, failed = 0, succeeded = 0 }
        
          for i = 1, #statusItems do
            if statusItems[i].status ~= nil then
              -- Aggregate time fields (earliest start time, latest completion time and reconcile time)
              if statusItems[i].status.startTime ~= nil then
                if startTime == nil or statusItems[i].status.startTime < startTime then
                  startTime = statusItems[i].status.startTime
                end
              end
              
              if statusItems[i].status.completionTime ~= nil then
                if completionTime == nil or statusItems[i].status.completionTime > completionTime then
                  completionTime = statusItems[i].status.completionTime
                end
              end
              
              if statusItems[i].status.lastReconcileTime ~= nil then
                if lastReconcileTime == nil or statusItems[i].status.lastReconcileTime > lastReconcileTime then
                  lastReconcileTime = statusItems[i].status.lastReconcileTime
                end
              end

              -- Aggregate replica status for all TFJob replica types
              if statusItems[i].status.replicaStatuses ~= nil then
                local replicaTypes = {"PS", "Worker", "Chief", "Master", "Evaluator"}
                for _, replicaType in ipairs(replicaTypes) do
                  if statusItems[i].status.replicaStatuses[replicaType] ~= nil then
                    replicaStatuses[replicaType].active = replicaStatuses[replicaType].active + (statusItems[i].status.replicaStatuses[replicaType].active or 0)
                    replicaStatuses[replicaType].failed = replicaStatuses[replicaType].failed + (statusItems[i].status.replicaStatuses[replicaType].failed or 0)
                    replicaStatuses[replicaType].succeeded = replicaStatuses[replicaType].succeeded + (statusItems[i].status.replicaStatuses[replicaType].succeeded or 0)
                  end
                end
              end
            
              -- Aggregate condition status (merge conditions from all member clusters)
              local isFinished = false
              local finishedType = ""
              if statusItems[i].status.conditions ~= nil then
                for _, c in ipairs(statusItems[i].status.conditions) do
                  -- Like kubernetes native Job, we do not merge conditions from member clusters, 
                  -- but generate a new condition by TFJob finish state.
                  -- table.insert(aggregatedConditions, c)
                  if (c.type == "Succeeded" or c.type == "Failed") and c.status == "True" then
                    isFinished = true
                    finishedType = c.type
                  end
                end
              end

              if isFinished then
                if finishedType == "Succeeded" then
                  successfulClustersNum = successfulClustersNum + 1
                elseif finishedType == "Failed" then
                  table.insert(failedClusters, statusItems[i].clusterName)
                end
              end

            end
          end
            
          if #failedClusters > 0 then
            table.insert(aggregatedConditions, {
              type = "Failed",
              status = "True",
              lastProbeTime = os.date("!%Y-%m-%dT%H:%M:%SZ"),
              lastTransitionTime = os.date("!%Y-%m-%dT%H:%M:%SZ"),
              reason = "TFJobFailed",
              message = "TFJob executed failed in member clusters: " .. table.concat(failedClusters, ", ")
            })
          end

          if successfulClustersNum == #statusItems and successfulClustersNum > 0 then
            table.insert(aggregatedConditions, {
              type = "Succeeded",
              status = "True",
              lastProbeTime = os.date("!%Y-%m-%dT%H:%M:%SZ"),
              lastTransitionTime = os.date("!%Y-%m-%dT%H:%M:%SZ"),
              reason = "Completed",
              message = "TFJob completed successfully"
            })
            desiredObj.status.completionTime = completionTime
          end
        
          -- Set aggregated status
          desiredObj.status.startTime = startTime
          desiredObj.status.lastReconcileTime = lastReconcileTime
          desiredObj.status.replicaStatuses = replicaStatuses
          desiredObj.status.conditions = aggregatedConditions
          local tmp = desiredObj.status
          desiredObj.status = omitEmpty(tmp)

          return desiredObj
        end
        
    healthInterpretation:
      luaScript: >
        function InterpretHealth(observedObj)
          if observedObj == nil or
             observedObj.status == nil or
             observedObj.status.conditions == nil then
            return false
          end
          
          -- Determine health based on TFJob status          
          for i = 1, #observedObj.status.conditions do
            local condition = observedObj.status.conditions[i]
            if condition.type == "Failed" and condition.status == "True" then
              return false
            end
          end
          return true
        end

    dependencyInterpretation:
      luaScript: >
        local kube = require("kube")
        function GetDependencies(desiredObj)
          local refs = {}
          
          if desiredObj.spec == nil or desiredObj.spec.tfReplicaSpecs == nil then
            return refs
          end
          
          -- Iterate all TFJob replica types
          local replicaTypes = {"PS", "Worker", "Chief", "Master", "Evaluator"}
          for _, replicaType in ipairs(replicaTypes) do
            local spec = desiredObj.spec.tfReplicaSpecs[replicaType]
            if spec ~= nil and spec.template ~= nil then
              local deps = kube.getPodDependencies(spec.template, desiredObj.metadata.namespace)
              if deps ~= nil then
                for _, dep in ipairs(deps) do
                  table.insert(refs, dep)
                end
              end
            end
          end
          
          return refs
        end

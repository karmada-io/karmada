// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify
/*
Copyright The Karmada Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package service

import (
	"context"

	"github.com/karmada-io/karmada/pkg/estimator/pb"
	mock "github.com/stretchr/testify/mock"
	"google.golang.org/grpc"
)

// NewMockEstimatorClient creates a new instance of MockEstimatorClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEstimatorClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEstimatorClient {
	mock := &MockEstimatorClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEstimatorClient is an autogenerated mock type for the EstimatorClient type
type MockEstimatorClient struct {
	mock.Mock
}

type MockEstimatorClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEstimatorClient) EXPECT() *MockEstimatorClient_Expecter {
	return &MockEstimatorClient_Expecter{mock: &_m.Mock}
}

// GetUnschedulableReplicas provides a mock function for the type MockEstimatorClient
func (_mock *MockEstimatorClient) GetUnschedulableReplicas(ctx context.Context, in *pb.UnschedulableReplicasRequest, opts ...grpc.CallOption) (*pb.UnschedulableReplicasResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetUnschedulableReplicas")
	}

	var r0 *pb.UnschedulableReplicasResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pb.UnschedulableReplicasRequest, ...grpc.CallOption) (*pb.UnschedulableReplicasResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pb.UnschedulableReplicasRequest, ...grpc.CallOption) *pb.UnschedulableReplicasResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.UnschedulableReplicasResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *pb.UnschedulableReplicasRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEstimatorClient_GetUnschedulableReplicas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUnschedulableReplicas'
type MockEstimatorClient_GetUnschedulableReplicas_Call struct {
	*mock.Call
}

// GetUnschedulableReplicas is a helper method to define mock.On call
//   - ctx context.Context
//   - in *pb.UnschedulableReplicasRequest
//   - opts ...grpc.CallOption
func (_e *MockEstimatorClient_Expecter) GetUnschedulableReplicas(ctx interface{}, in interface{}, opts ...interface{}) *MockEstimatorClient_GetUnschedulableReplicas_Call {
	return &MockEstimatorClient_GetUnschedulableReplicas_Call{Call: _e.mock.On("GetUnschedulableReplicas",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockEstimatorClient_GetUnschedulableReplicas_Call) Run(run func(ctx context.Context, in *pb.UnschedulableReplicasRequest, opts ...grpc.CallOption)) *MockEstimatorClient_GetUnschedulableReplicas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pb.UnschedulableReplicasRequest
		if args[1] != nil {
			arg1 = args[1].(*pb.UnschedulableReplicasRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockEstimatorClient_GetUnschedulableReplicas_Call) Return(unschedulableReplicasResponse *pb.UnschedulableReplicasResponse, err error) *MockEstimatorClient_GetUnschedulableReplicas_Call {
	_c.Call.Return(unschedulableReplicasResponse, err)
	return _c
}

func (_c *MockEstimatorClient_GetUnschedulableReplicas_Call) RunAndReturn(run func(ctx context.Context, in *pb.UnschedulableReplicasRequest, opts ...grpc.CallOption) (*pb.UnschedulableReplicasResponse, error)) *MockEstimatorClient_GetUnschedulableReplicas_Call {
	_c.Call.Return(run)
	return _c
}

// MaxAvailableReplicas provides a mock function for the type MockEstimatorClient
func (_mock *MockEstimatorClient) MaxAvailableReplicas(ctx context.Context, in *pb.MaxAvailableReplicasRequest, opts ...grpc.CallOption) (*pb.MaxAvailableReplicasResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for MaxAvailableReplicas")
	}

	var r0 *pb.MaxAvailableReplicasResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pb.MaxAvailableReplicasRequest, ...grpc.CallOption) (*pb.MaxAvailableReplicasResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pb.MaxAvailableReplicasRequest, ...grpc.CallOption) *pb.MaxAvailableReplicasResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.MaxAvailableReplicasResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *pb.MaxAvailableReplicasRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEstimatorClient_MaxAvailableReplicas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxAvailableReplicas'
type MockEstimatorClient_MaxAvailableReplicas_Call struct {
	*mock.Call
}

// MaxAvailableReplicas is a helper method to define mock.On call
//   - ctx context.Context
//   - in *pb.MaxAvailableReplicasRequest
//   - opts ...grpc.CallOption
func (_e *MockEstimatorClient_Expecter) MaxAvailableReplicas(ctx interface{}, in interface{}, opts ...interface{}) *MockEstimatorClient_MaxAvailableReplicas_Call {
	return &MockEstimatorClient_MaxAvailableReplicas_Call{Call: _e.mock.On("MaxAvailableReplicas",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockEstimatorClient_MaxAvailableReplicas_Call) Run(run func(ctx context.Context, in *pb.MaxAvailableReplicasRequest, opts ...grpc.CallOption)) *MockEstimatorClient_MaxAvailableReplicas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pb.MaxAvailableReplicasRequest
		if args[1] != nil {
			arg1 = args[1].(*pb.MaxAvailableReplicasRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockEstimatorClient_MaxAvailableReplicas_Call) Return(maxAvailableReplicasResponse *pb.MaxAvailableReplicasResponse, err error) *MockEstimatorClient_MaxAvailableReplicas_Call {
	_c.Call.Return(maxAvailableReplicasResponse, err)
	return _c
}

func (_c *MockEstimatorClient_MaxAvailableReplicas_Call) RunAndReturn(run func(ctx context.Context, in *pb.MaxAvailableReplicasRequest, opts ...grpc.CallOption) (*pb.MaxAvailableReplicasResponse, error)) *MockEstimatorClient_MaxAvailableReplicas_Call {
	_c.Call.Return(run)
	return _c
}

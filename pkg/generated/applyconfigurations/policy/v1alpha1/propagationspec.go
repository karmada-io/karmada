/*
Copyright The Karmada Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

import (
	policyv1alpha1 "github.com/karmada-io/karmada/pkg/apis/policy/v1alpha1"
)

// PropagationSpecApplyConfiguration represents a declarative configuration of the PropagationSpec type for use
// with apply.
//
// PropagationSpec represents the desired behavior of PropagationPolicy.
type PropagationSpecApplyConfiguration struct {
	// ResourceSelectors used to select resources.
	// Nil or empty selector is not allowed and doesn't mean match all kinds
	// of resources for security concerns that sensitive resources(like Secret)
	// might be accidentally propagated.
	ResourceSelectors []ResourceSelectorApplyConfiguration `json:"resourceSelectors,omitempty"`
	// Association tells if relevant resources should be selected automatically.
	// e.g. a ConfigMap referred by a Deployment.
	// default false.
	// Deprecated: in favor of PropagateDeps.
	Association *bool `json:"association,omitempty"`
	// PropagateDeps tells if relevant resources should be propagated automatically.
	// Take 'Deployment' which referencing 'ConfigMap' and 'Secret' as an example, when 'propagateDeps' is 'true',
	// the referencing resources could be omitted(for saving config effort) from 'resourceSelectors' as they will be
	// propagated along with the Deployment. In addition to the propagating process, the referencing resources will be
	// migrated along with the Deployment in the fail-over scenario.
	//
	// Defaults to false.
	PropagateDeps *bool `json:"propagateDeps,omitempty"`
	// Placement represents the rule for select clusters to propagate resources.
	Placement *PlacementApplyConfiguration `json:"placement,omitempty"`
	// Priority indicates the importance of a policy(PropagationPolicy or ClusterPropagationPolicy).
	// A policy will be applied for the matched resource templates if there is
	// no other policies with higher priority at the point of the resource
	// template be processed.
	// Once a resource template has been claimed by a policy, by default it will
	// not be preempted by following policies even with a higher priority.
	// See Preemption for more details.
	//
	// In case of two policies have the same priority, the one with a more precise
	// matching rules in ResourceSelectors wins:
	// - matching by name(resourceSelector.name) has higher priority than
	// by selector(resourceSelector.labelSelector)
	// - matching by selector(resourceSelector.labelSelector) has higher priority
	// than by APIVersion(resourceSelector.apiVersion) and Kind(resourceSelector.kind).
	// If there is still no winner at this point, the one with the lower alphabetic
	// order wins, e.g. policy 'bar' has higher priority than 'foo'.
	//
	// The higher the value, the higher the priority. Defaults to zero.
	Priority *int32 `json:"priority,omitempty"`
	// Preemption declares the behaviors for preempting.
	// Valid options are "Always" and "Never".
	Preemption *policyv1alpha1.PreemptionBehavior `json:"preemption,omitempty"`
	// DependentOverrides represents the list of overrides(OverridePolicy)
	// which must present before the current PropagationPolicy takes effect.
	//
	// It used to explicitly specify overrides which current PropagationPolicy rely on.
	// A typical scenario is the users create OverridePolicy(ies) and resources at the same time,
	// they want to ensure the new-created policies would be adopted.
	//
	// Note: For the overrides, OverridePolicy(ies) in current namespace and ClusterOverridePolicy(ies),
	// which not present in this list will still be applied if they matches the resources.
	DependentOverrides []string `json:"dependentOverrides,omitempty"`
	// SchedulerName represents which scheduler to proceed the scheduling.
	// If specified, the policy will be dispatched by specified scheduler.
	// If not specified, the policy will be dispatched by default scheduler.
	SchedulerName *string `json:"schedulerName,omitempty"`
	// Failover indicates how Karmada migrates applications in case of failures.
	// If this value is nil, failover is disabled.
	Failover *FailoverBehaviorApplyConfiguration `json:"failover,omitempty"`
	// ConflictResolution declares how potential conflict should be handled when
	// a resource that is being propagated already exists in the target cluster.
	//
	// It defaults to "Abort" which means stop propagating to avoid unexpected
	// overwrites. The "Overwrite" might be useful when migrating legacy cluster
	// resources to Karmada, in which case conflict is predictable and can be
	// instructed to Karmada take over the resource by overwriting.
	ConflictResolution *policyv1alpha1.ConflictResolution `json:"conflictResolution,omitempty"`
	// ActivationPreference indicates how the referencing resource template will
	// be propagated, in case of policy changes.
	//
	// If empty, the resource template will respond to policy changes
	// immediately, in other words, any policy changes will drive the resource
	// template to be propagated immediately as per the current propagation rules.
	//
	// If the value is 'Lazy' means the policy changes will not take effect for now
	// but defer to the resource template changes, in other words, the resource
	// template will not be propagated as per the current propagation rules until
	// there is an update on it.
	// This is an experimental feature that might help in a scenario where a policy
	// manages huge amount of resource templates, changes to a policy typically
	// affect numerous applications simultaneously. A minor misconfiguration
	// could lead to widespread failures. With this feature, the change can be
	// gradually rolled out through iterative modifications of resource templates.
	ActivationPreference *policyv1alpha1.ActivationPreference `json:"activationPreference,omitempty"`
	// Suspension declares the policy for suspending different aspects of propagation.
	// nil means no suspension. no default values.
	Suspension *SuspensionApplyConfiguration `json:"suspension,omitempty"`
	// PreserveResourcesOnDeletion controls whether resources should be preserved on the
	// member clusters when the resource template is deleted.
	// If set to true, resources will be preserved on the member clusters.
	// Default is false, which means resources will be deleted along with the resource template.
	//
	// This setting is particularly useful during workload migration scenarios to ensure
	// that rollback can occur quickly without affecting the workloads running on the
	// member clusters.
	//
	// Additionally, this setting applies uniformly across all member clusters and will not
	// selectively control preservation on only some clusters.
	//
	// Note: This setting does not apply to the deletion of the policy itself.
	// When the policy is deleted, the resource templates and their corresponding
	// propagated resources in member clusters will remain unchanged unless explicitly deleted.
	PreserveResourcesOnDeletion *bool `json:"preserveResourcesOnDeletion,omitempty"`
	// SchedulePriority defines how Karmada should resolve the priority and preemption policy
	// for workload scheduling.
	//
	// This setting is useful for controlling the scheduling behavior of offline workloads.
	// By setting a higher or lower priority, users can control which workloads are scheduled first.
	// Additionally, it allows specifying a preemption policy where higher-priority workloads can
	// preempt lower-priority ones in scenarios of resource contention.
	//
	// Note: This feature is currently in the alpha stage. The priority-based scheduling functionality is
	// controlled by the PriorityBasedScheduling feature gate, and preemption is controlled by the
	// PriorityBasedPreemptiveScheduling feature gate. Currently, only priority-based scheduling is
	// supported. Preemption functionality is not yet available and will be introduced in future
	// releases as the feature matures.
	SchedulePriority *SchedulePriorityApplyConfiguration `json:"schedulePriority,omitempty"`
}

// PropagationSpecApplyConfiguration constructs a declarative configuration of the PropagationSpec type for use with
// apply.
func PropagationSpec() *PropagationSpecApplyConfiguration {
	return &PropagationSpecApplyConfiguration{}
}

// WithResourceSelectors adds the given value to the ResourceSelectors field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ResourceSelectors field.
func (b *PropagationSpecApplyConfiguration) WithResourceSelectors(values ...*ResourceSelectorApplyConfiguration) *PropagationSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithResourceSelectors")
		}
		b.ResourceSelectors = append(b.ResourceSelectors, *values[i])
	}
	return b
}

// WithAssociation sets the Association field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Association field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithAssociation(value bool) *PropagationSpecApplyConfiguration {
	b.Association = &value
	return b
}

// WithPropagateDeps sets the PropagateDeps field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PropagateDeps field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithPropagateDeps(value bool) *PropagationSpecApplyConfiguration {
	b.PropagateDeps = &value
	return b
}

// WithPlacement sets the Placement field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Placement field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithPlacement(value *PlacementApplyConfiguration) *PropagationSpecApplyConfiguration {
	b.Placement = value
	return b
}

// WithPriority sets the Priority field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Priority field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithPriority(value int32) *PropagationSpecApplyConfiguration {
	b.Priority = &value
	return b
}

// WithPreemption sets the Preemption field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Preemption field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithPreemption(value policyv1alpha1.PreemptionBehavior) *PropagationSpecApplyConfiguration {
	b.Preemption = &value
	return b
}

// WithDependentOverrides adds the given value to the DependentOverrides field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DependentOverrides field.
func (b *PropagationSpecApplyConfiguration) WithDependentOverrides(values ...string) *PropagationSpecApplyConfiguration {
	for i := range values {
		b.DependentOverrides = append(b.DependentOverrides, values[i])
	}
	return b
}

// WithSchedulerName sets the SchedulerName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SchedulerName field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithSchedulerName(value string) *PropagationSpecApplyConfiguration {
	b.SchedulerName = &value
	return b
}

// WithFailover sets the Failover field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Failover field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithFailover(value *FailoverBehaviorApplyConfiguration) *PropagationSpecApplyConfiguration {
	b.Failover = value
	return b
}

// WithConflictResolution sets the ConflictResolution field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ConflictResolution field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithConflictResolution(value policyv1alpha1.ConflictResolution) *PropagationSpecApplyConfiguration {
	b.ConflictResolution = &value
	return b
}

// WithActivationPreference sets the ActivationPreference field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ActivationPreference field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithActivationPreference(value policyv1alpha1.ActivationPreference) *PropagationSpecApplyConfiguration {
	b.ActivationPreference = &value
	return b
}

// WithSuspension sets the Suspension field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Suspension field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithSuspension(value *SuspensionApplyConfiguration) *PropagationSpecApplyConfiguration {
	b.Suspension = value
	return b
}

// WithPreserveResourcesOnDeletion sets the PreserveResourcesOnDeletion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PreserveResourcesOnDeletion field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithPreserveResourcesOnDeletion(value bool) *PropagationSpecApplyConfiguration {
	b.PreserveResourcesOnDeletion = &value
	return b
}

// WithSchedulePriority sets the SchedulePriority field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SchedulePriority field is set to the value of the last call.
func (b *PropagationSpecApplyConfiguration) WithSchedulePriority(value *SchedulePriorityApplyConfiguration) *PropagationSpecApplyConfiguration {
	b.SchedulePriority = value
	return b
}

/*
Copyright The Karmada Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha2

import (
	policyv1alpha1 "github.com/karmada-io/karmada/pkg/apis/policy/v1alpha1"
	v1alpha1 "github.com/karmada-io/karmada/pkg/generated/applyconfigurations/policy/v1alpha1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ResourceBindingSpecApplyConfiguration represents a declarative configuration of the ResourceBindingSpec type for use
// with apply.
//
// ResourceBindingSpec represents the expectation of ResourceBinding.
type ResourceBindingSpecApplyConfiguration struct {
	// Resource represents the Kubernetes resource to be propagated.
	Resource *ObjectReferenceApplyConfiguration `json:"resource,omitempty"`
	// PropagateDeps tells if relevant resources should be propagated automatically.
	// It is inherited from PropagationPolicy or ClusterPropagationPolicy.
	// default false.
	PropagateDeps *bool `json:"propagateDeps,omitempty"`
	// ReplicaRequirements represents the resource and scheduling requirements for each replica.
	ReplicaRequirements *ReplicaRequirementsApplyConfiguration `json:"replicaRequirements,omitempty"`
	// Replicas represents the replica number of the referencing resource.
	Replicas *int32 `json:"replicas,omitempty"`
	// Components represents the requirements of multiple pod templates of the referencing resource.
	// It is designed to support workloads that consist of multiple pod templates,
	// such as distributed training jobs (e.g., PyTorch, TensorFlow) and big data workloads (e.g., FlinkDeployment),
	// where each workload is composed of more than one pod template. It is also capable of representing
	// single-component workloads, such as Deployment.
	//
	// Note: This field is intended to replace the legacy ReplicaRequirements and Replicas fields above.
	// It is only populated when the MultiplePodTemplatesScheduling feature gate is enabled.
	Components []ComponentApplyConfiguration `json:"components,omitempty"`
	// Clusters represents target member clusters where the resource to be deployed.
	Clusters []TargetClusterApplyConfiguration `json:"clusters,omitempty"`
	// Placement represents the rule for select clusters to propagate resources.
	Placement *v1alpha1.PlacementApplyConfiguration `json:"placement,omitempty"`
	// GracefulEvictionTasks holds the eviction tasks that are expected to perform
	// the eviction in a graceful way.
	// The intended workflow is:
	// 1. Once the controller(such as 'taint-manager') decided to evict the resource that
	// is referenced by current ResourceBinding or ClusterResourceBinding from a target
	// cluster, it removes(or scale down the replicas) the target from Clusters(.spec.Clusters)
	// and builds a graceful eviction task.
	// 2. The scheduler may perform a re-scheduler and probably select a substitute cluster
	// to take over the evicting workload(resource).
	// 3. The graceful eviction controller takes care of the graceful eviction tasks and
	// performs the final removal after the workload(resource) is available on the substitute
	// cluster or exceed the grace termination period(defaults to 10 minutes).
	GracefulEvictionTasks []GracefulEvictionTaskApplyConfiguration `json:"gracefulEvictionTasks,omitempty"`
	// RequiredBy represents the list of Bindings that depend on the referencing resource.
	RequiredBy []BindingSnapshotApplyConfiguration `json:"requiredBy,omitempty"`
	// SchedulerName represents which scheduler to proceed the scheduling.
	// It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
	SchedulerName *string `json:"schedulerName,omitempty"`
	// Failover indicates how Karmada migrates applications in case of failures.
	// It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
	Failover *v1alpha1.FailoverBehaviorApplyConfiguration `json:"failover,omitempty"`
	// ConflictResolution declares how potential conflict should be handled when
	// a resource that is being propagated already exists in the target cluster.
	//
	// It defaults to "Abort" which means stop propagating to avoid unexpected
	// overwrites. The "Overwrite" might be useful when migrating legacy cluster
	// resources to Karmada, in which case conflict is predictable and can be
	// instructed to Karmada take over the resource by overwriting.
	ConflictResolution *policyv1alpha1.ConflictResolution `json:"conflictResolution,omitempty"`
	// RescheduleTriggeredAt is a timestamp representing when the referenced resource is triggered rescheduling.
	// When this field is updated, it means a rescheduling is manually triggered by user, and the expected behavior
	// of this action is to do a complete recalculation without referring to last scheduling results.
	// It works with the status.lastScheduledTime field, and only when this timestamp is later than timestamp in
	// status.lastScheduledTime will the rescheduling actually execute, otherwise, ignored.
	//
	// It is represented in RFC3339 form (like '2006-01-02T15:04:05Z') and is in UTC.
	RescheduleTriggeredAt *v1.Time `json:"rescheduleTriggeredAt,omitempty"`
	// Suspension declares the policy for suspending different aspects of propagation.
	// nil means no suspension. no default values.
	Suspension *SuspensionApplyConfiguration `json:"suspension,omitempty"`
	// PreserveResourcesOnDeletion controls whether resources should be preserved on the
	// member clusters when the binding object is deleted.
	// If set to true, resources will be preserved on the member clusters.
	// Default is false, which means resources will be deleted along with the binding object.
	// This setting applies to all Work objects created under this binding object.
	PreserveResourcesOnDeletion *bool `json:"preserveResourcesOnDeletion,omitempty"`
	// SchedulePriority represents the scheduling priority assigned to workloads.
	SchedulePriority *SchedulePriorityApplyConfiguration `json:"schedulePriority,omitempty"`
	// WorkloadAffinityGroups represents instantiated grouping results from .spec.placement.workloadAffinity,
	// used to keep workloads with the same affinity group co-located or those with the same
	// anti-affinity group separated across clusters. Populated by controllers, the scheduler
	// consumes it for decisions.
	WorkloadAffinityGroups *WorkloadAffinityGroupsApplyConfiguration `json:"workloadAffinityGroups,omitempty"`
}

// ResourceBindingSpecApplyConfiguration constructs a declarative configuration of the ResourceBindingSpec type for use with
// apply.
func ResourceBindingSpec() *ResourceBindingSpecApplyConfiguration {
	return &ResourceBindingSpecApplyConfiguration{}
}

// WithResource sets the Resource field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Resource field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithResource(value *ObjectReferenceApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.Resource = value
	return b
}

// WithPropagateDeps sets the PropagateDeps field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PropagateDeps field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithPropagateDeps(value bool) *ResourceBindingSpecApplyConfiguration {
	b.PropagateDeps = &value
	return b
}

// WithReplicaRequirements sets the ReplicaRequirements field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ReplicaRequirements field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithReplicaRequirements(value *ReplicaRequirementsApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.ReplicaRequirements = value
	return b
}

// WithReplicas sets the Replicas field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Replicas field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithReplicas(value int32) *ResourceBindingSpecApplyConfiguration {
	b.Replicas = &value
	return b
}

// WithComponents adds the given value to the Components field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Components field.
func (b *ResourceBindingSpecApplyConfiguration) WithComponents(values ...*ComponentApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithComponents")
		}
		b.Components = append(b.Components, *values[i])
	}
	return b
}

// WithClusters adds the given value to the Clusters field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Clusters field.
func (b *ResourceBindingSpecApplyConfiguration) WithClusters(values ...*TargetClusterApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithClusters")
		}
		b.Clusters = append(b.Clusters, *values[i])
	}
	return b
}

// WithPlacement sets the Placement field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Placement field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithPlacement(value *v1alpha1.PlacementApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.Placement = value
	return b
}

// WithGracefulEvictionTasks adds the given value to the GracefulEvictionTasks field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the GracefulEvictionTasks field.
func (b *ResourceBindingSpecApplyConfiguration) WithGracefulEvictionTasks(values ...*GracefulEvictionTaskApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithGracefulEvictionTasks")
		}
		b.GracefulEvictionTasks = append(b.GracefulEvictionTasks, *values[i])
	}
	return b
}

// WithRequiredBy adds the given value to the RequiredBy field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RequiredBy field.
func (b *ResourceBindingSpecApplyConfiguration) WithRequiredBy(values ...*BindingSnapshotApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithRequiredBy")
		}
		b.RequiredBy = append(b.RequiredBy, *values[i])
	}
	return b
}

// WithSchedulerName sets the SchedulerName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SchedulerName field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithSchedulerName(value string) *ResourceBindingSpecApplyConfiguration {
	b.SchedulerName = &value
	return b
}

// WithFailover sets the Failover field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Failover field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithFailover(value *v1alpha1.FailoverBehaviorApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.Failover = value
	return b
}

// WithConflictResolution sets the ConflictResolution field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ConflictResolution field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithConflictResolution(value policyv1alpha1.ConflictResolution) *ResourceBindingSpecApplyConfiguration {
	b.ConflictResolution = &value
	return b
}

// WithRescheduleTriggeredAt sets the RescheduleTriggeredAt field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RescheduleTriggeredAt field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithRescheduleTriggeredAt(value v1.Time) *ResourceBindingSpecApplyConfiguration {
	b.RescheduleTriggeredAt = &value
	return b
}

// WithSuspension sets the Suspension field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Suspension field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithSuspension(value *SuspensionApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.Suspension = value
	return b
}

// WithPreserveResourcesOnDeletion sets the PreserveResourcesOnDeletion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PreserveResourcesOnDeletion field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithPreserveResourcesOnDeletion(value bool) *ResourceBindingSpecApplyConfiguration {
	b.PreserveResourcesOnDeletion = &value
	return b
}

// WithSchedulePriority sets the SchedulePriority field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SchedulePriority field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithSchedulePriority(value *SchedulePriorityApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.SchedulePriority = value
	return b
}

// WithWorkloadAffinityGroups sets the WorkloadAffinityGroups field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the WorkloadAffinityGroups field is set to the value of the last call.
func (b *ResourceBindingSpecApplyConfiguration) WithWorkloadAffinityGroups(value *WorkloadAffinityGroupsApplyConfiguration) *ResourceBindingSpecApplyConfiguration {
	b.WorkloadAffinityGroups = value
	return b
}

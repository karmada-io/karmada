// Code generated by MockGen. DO NOT EDIT.
// Source: multi_cluster_manager.go

// Package testing is a generated GoMock package.
package testing

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	genericmanager "github.com/karmada-io/karmada/pkg/util/fedinformer/genericmanager"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	dynamic "k8s.io/client-go/dynamic"
)

// MockMultiClusterInformerManager is a mock of MultiClusterInformerManager interface.
type MockMultiClusterInformerManager struct {
	ctrl     *gomock.Controller
	recorder *MockMultiClusterInformerManagerMockRecorder
}

// MockMultiClusterInformerManagerMockRecorder is the mock recorder for MockMultiClusterInformerManager.
type MockMultiClusterInformerManagerMockRecorder struct {
	mock *MockMultiClusterInformerManager
}

// NewMockMultiClusterInformerManager creates a new mock instance.
func NewMockMultiClusterInformerManager(ctrl *gomock.Controller) *MockMultiClusterInformerManager {
	mock := &MockMultiClusterInformerManager{ctrl: ctrl}
	mock.recorder = &MockMultiClusterInformerManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiClusterInformerManager) EXPECT() *MockMultiClusterInformerManagerMockRecorder {
	return m.recorder
}

// ForCluster mocks base method.
func (m *MockMultiClusterInformerManager) ForCluster(cluster string, client dynamic.Interface, defaultResync time.Duration) genericmanager.SingleClusterInformerManager {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForCluster", cluster, client, defaultResync)
	ret0, _ := ret[0].(genericmanager.SingleClusterInformerManager)
	return ret0
}

// ForCluster indicates an expected call of ForCluster.
func (mr *MockMultiClusterInformerManagerMockRecorder) ForCluster(cluster, client, defaultResync interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForCluster", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).ForCluster), cluster, client, defaultResync)
}

// GetSingleClusterManager mocks base method.
func (m *MockMultiClusterInformerManager) GetSingleClusterManager(cluster string) genericmanager.SingleClusterInformerManager {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSingleClusterManager", cluster)
	ret0, _ := ret[0].(genericmanager.SingleClusterInformerManager)
	return ret0
}

// GetSingleClusterManager indicates an expected call of GetSingleClusterManager.
func (mr *MockMultiClusterInformerManagerMockRecorder) GetSingleClusterManager(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSingleClusterManager", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).GetSingleClusterManager), cluster)
}

// IsManagerExist mocks base method.
func (m *MockMultiClusterInformerManager) IsManagerExist(cluster string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsManagerExist", cluster)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsManagerExist indicates an expected call of IsManagerExist.
func (mr *MockMultiClusterInformerManagerMockRecorder) IsManagerExist(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsManagerExist", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).IsManagerExist), cluster)
}

// Start mocks base method.
func (m *MockMultiClusterInformerManager) Start(cluster string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start", cluster)
}

// Start indicates an expected call of Start.
func (mr *MockMultiClusterInformerManagerMockRecorder) Start(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).Start), cluster)
}

// Stop mocks base method.
func (m *MockMultiClusterInformerManager) Stop(cluster string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop", cluster)
}

// Stop indicates an expected call of Stop.
func (mr *MockMultiClusterInformerManagerMockRecorder) Stop(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).Stop), cluster)
}

// WaitForCacheSync mocks base method.
func (m *MockMultiClusterInformerManager) WaitForCacheSync(cluster string) map[schema.GroupVersionResource]bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForCacheSync", cluster)
	ret0, _ := ret[0].(map[schema.GroupVersionResource]bool)
	return ret0
}

// WaitForCacheSync indicates an expected call of WaitForCacheSync.
func (mr *MockMultiClusterInformerManagerMockRecorder) WaitForCacheSync(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForCacheSync", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).WaitForCacheSync), cluster)
}

// WaitForCacheSyncWithTimeout mocks base method.
func (m *MockMultiClusterInformerManager) WaitForCacheSyncWithTimeout(cluster string, cacheSyncTimeout time.Duration) map[schema.GroupVersionResource]bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForCacheSyncWithTimeout", cluster, cacheSyncTimeout)
	ret0, _ := ret[0].(map[schema.GroupVersionResource]bool)
	return ret0
}

// WaitForCacheSyncWithTimeout indicates an expected call of WaitForCacheSyncWithTimeout.
func (mr *MockMultiClusterInformerManagerMockRecorder) WaitForCacheSyncWithTimeout(cluster, cacheSyncTimeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForCacheSyncWithTimeout", reflect.TypeOf((*MockMultiClusterInformerManager)(nil).WaitForCacheSyncWithTimeout), cluster, cacheSyncTimeout)
}
